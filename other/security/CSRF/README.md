## CSRF
###### [wiki链接](https://zh.wikipedia.org/wiki/跨站请求伪造)
- 跨站请求伪造（英语：Cross-site request forgery），
- 也被称为one-click attack 或者 session riding，
- 通常缩写为 CSRF 或者XSRF， 是一种挟制用户在当前已登录
的Web应用程序上执行非本意的操作的攻击方法。
- 跟跨网站脚本（XSS）相比：
  ```text
  1. XSS利用的是用户对指定网站的信任，
  2. CSRF利用的是网站对用户网页浏览器的信任。
  3. XSS是源于代码注入方式，js引擎把输入作为脚本执行。
  4. CSRF是源于欺骗用户浏览器，让其以用户的名义运行操作。
  ```

###### example:
假如一家银行用以运行转账操作的URL地址如下： 

`http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName`

那么，一个恶意攻击者可以在另一个网站上放置如下代码： 

`<img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">`

如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，
登录信息尚未过期，那么她就会损失1000资金。

这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。
此外，攻击者也不需要控制放置恶意网址的网站。
例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。
这意味着如果服务端没有合适的防御措施的话，
用户即使访问熟悉的可信网站也有受攻击的危险。

在上面示例里，能够看出，
攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。
他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。

#### 主要危害：
1. 可以盗用受害者的身份，完成受害者在web浏览器对目标站点有权限进行的任何操作。

#### 主要解决办法：
###### 概要
```text
如果选择不支持低版本浏览器（ie6），检查referer字段就足够，
如果需要支持，那就添加校验token，特殊地方使用特殊token。
```

1. 检查Referer字段

HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。
在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。
以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，
应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，
Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，
这时候服务器就能识别出恶意的访问。

这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。
但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。
虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，
亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，
篡改其Referer字段的可能。

2. 添加校验token

由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，
所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，
并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。
这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，
其内容是一个伪随机数。当客户端通过窗体提交请求时，
这个伪随机数也一并提交上去以供校验。正常的访问时，
客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，
攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，
拒绝这个可疑请求。

3. 在 HTTP 头中自定义属性并验证
这种方法也是使用 token 并进行验证，和上一种方法不同的是，
这里并不是把 token 以参数的形式置于 HTTP 请求之中，
而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，
可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，
并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，
同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，
也不用担心 token 会透过 Referer 泄露到其他网站中去。